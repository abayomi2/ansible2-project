Production-Grade Application Deployment with Terraform and Ansible
This project automates the deployment of a containerized application and a full observability stack (Prometheus & Grafana) on AWS. It follows Infrastructure as Code (IaC) and Configuration Management best practices to create a secure, scalable, and repeatable production-grade environment.

Table of Contents
Architecture

Features

Project Structure

Prerequisites

Manual Deployment Guide

Step 1: Environment Setup

Step 2: Provision Infrastructure with Terraform

Step 3: Configure Servers with Ansible

Step 4: Verify the Deployment

Step 5: Clean Up

Next Steps

Architecture
This project uses a decoupled architecture where infrastructure provisioning is handled by Terraform and server configuration is managed by Ansible.

Terraform: Provisions all necessary AWS resources, including:

Three EC2 instances (for the Application, Prometheus, and Grafana).

Three granular Security Groups to enforce a strict network firewall, allowing traffic only where necessary.

An SSH key pair for secure access.

After provisioning, Terraform dynamically generates an inventory file for Ansible.

Ansible: Configures the provisioned EC2 instances by:

Installing common packages and hardening the base OS.

Deploying the containerized application using Docker on the application host.

Installing and configuring Node Exporter on the application host to collect system metrics.

Installing and configuring Prometheus on its dedicated server to scrape metrics from Node Exporter.

Installing and configuring Grafana on its dedicated server, automatically adding Prometheus as a data source and importing a dashboard for visualization.

Observability Flow:

Node Exporter exposes metrics on the app server (port 9100).

Prometheus scrapes these metrics (port 9090).

Grafana queries Prometheus and visualizes the data (port 3000).

Features
Fully Automated Deployment: From cloud resources to application code, the entire stack is deployed automatically.

Infrastructure as Code (IaC): All infrastructure is defined in Terraform, ensuring consistency and version control.

Configuration as Code: Server state is defined using Ansible Roles, promoting modularity and reusability.

Secure by Default:

Uses SSH keys for access (no password authentication).

Implements the principle of least privilege with strict Security Group rules.

Manages secrets (like the Grafana password) securely using Ansible Vault.

Robust Observability: A complete monitoring and visualization stack is set up to provide insights into application and system performance.

Idempotent: Both Terraform and Ansible playbooks can be run multiple times, with the system converging to the same desired state without errors.

Project Structure
.
├── ansible/
│   ├── roles/
│   │   ├── app_host/         # Deploys the containerized application
│   │   ├── common/           # Common setup for all servers
│   │   ├── grafana/          # Installs and configures Grafana
│   │   ├── node_exporter/    # Installs Node Exporter
│   │   └── prometheus/       # Installs and configures Prometheus
│   ├── group_vars/
│   │   ├── all/
│   │   │   ├── main.yml
│   │   │   └── vault.yml     # Encrypted secrets
│   ├── inventory/
│   │   └── production.ini    # Dynamically generated by Terraform
│   ├── ansible.cfg           # Ansible configuration
│   └── main-playbook.yml     # Main playbook to orchestrate roles
├── terraform/
│   ├── main.tf               # Main Terraform definitions
│   ├── outputs.tf            # Terraform outputs
│   ├── inventory.tpl         # Template for the Ansible inventory
│   └── variables.tf
└── prod-kp.pem               # SSH Private Key (ensure permissions are 600)

Prerequisites
AWS Account: With credentials configured for the AWS CLI.

Terraform: Installed locally.

Ansible: Installed locally.

AWS CLI: Installed and configured (aws configure).

SSH Key Pair: An SSH key pair created in the target AWS region.

Docker Hub Image: A containerized application image pushed to Docker Hub.

Manual Deployment Guide
Step 1: Environment Setup
Clone the Repository:

git clone <your-repo-url>
cd <your-project-directory>

Configure Terraform Variables:

In terraform/main.tf, update the cidr_blocks for SSH (port 22) and UI access (ports 3000, 9090) to your personal or office IP address.

Ensure the key_name in the aws_instance resources matches your AWS key pair name.

Configure Ansible Variables:

In ansible/group_vars/all/vault.yml, store your desired Grafana admin password using ansible-vault edit.

ansible-vault create ansible/group_vars/all/vault.yml
# Add: grafana_admin_password: "YourSecurePassword"

In ansible/roles/app_host/tasks/main.yml, update the image parameter in the docker_container task to point to your Docker Hub image.

Set SSH Key Permissions:

Ensure your private key file (prod-kp.pem) is in the project root and has the correct permissions.

chmod 600 prod-kp.pem

Step 2: Provision Infrastructure with Terraform
Navigate to the Terraform directory:

cd terraform/

Initialize Terraform:

terraform init

Apply the configuration:

This will create all AWS resources and generate the Ansible inventory file at ansible/inventory/production.ini.

terraform apply -auto-approve

Step 3: Configure Servers with Ansible
Navigate to the Ansible directory:

cd ../ansible/

Run the Ansible Playbook:

You will be prompted for the vault password you created in Step 1.

ansible-playbook -i inventory/production.ini main-playbook.yml --ask-vault-pass

Step 4: Verify the Deployment
Application: http://<app_host_ip>:8080

Prometheus: http://<prometheus_ip>:9090

Grafana: http://<grafana_ip>:3000

User: admin

Password: The password from your Ansible Vault.

Step 5: Clean Up
To avoid ongoing AWS charges, destroy all created resources when you are finished.

Navigate to the Terraform directory:

cd ../terraform/

Destroy all resources:

terraform destroy -auto-approve

Next Steps
CI/CD Automation: Implement a GitHub Actions workflow (.github/workflows/deploy.yml) to fully automate the terraform apply and ansible-playbook steps on every push to the main branch.

Load Balancer: For a public-facing application, add an Application Load Balancer in front of the application server for enhanced security and scalability.

Domain Names & DNS: Use AWS Route 53 to assign proper domain names to your services instead of using raw IP addresses.
